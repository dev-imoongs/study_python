# study_python
<a name="readme-top"></a>
## python 기초

### A. 변수
변수 - 저장 공간
    변수는 값을 담는 저장 공간이다.
    x = 10, x라는 이름의 저장 공간이 RAM(메모리)에 할당되고 10이라는 값이 들어간다.

자료형 (Type) - 저장공간의 종류
    동적 바인딩: 값에 따라 자료형이 정해진다

    자료형(type)	    값
    정수(int)	    0, 10, -187, ...
    실수(float)	    0.0, 10.58, -77.568, ...
    문자열(str)	    '0', "0.0", """한동석""", '''Python''', ...
    리스트(list)	    [1, 2, 3], [0], [3,], ...
    튜플(tuple)	    (1, 2), (), 1, 2, 3, (1,), ...
    딕셔너리(dict)	{key:value,}, ...
    집합(set)	    {1, 2, 3}, {1}, ...
    불린(bool)	    True, False

변수명 주의사항

    문자로 시작해야 한다.
    특수문자는 사용할 수 없다. 단, _는 허용한다.
    소문자로 시작한다.
    공백을 사용할 수 없다.
    되도록 한글은 사용하지 않는다.
    명사로 사용한다.
    뜻이 있는 단어를 사용한다.
        - a, b, c, d, e, ... (X)
        - data, number, age, name, ...(O)

표기법

    * 파스칼 표기법(클래스명, 오류명)
        대문자로 시작하고 이어지는 단어들의 시작은 대문자로 작성
        PascalCase

    카멜 표기법(JAVA 등에서 사용)
        소문자로 시작하고 이어지는 단어들의 시작은 대문자로 작성
        camelCase

    * 스네이크 표기법(변수, 함수)
        단어 사이에 언더스코어(_)를 작성
        snake_case

    케밥 표기법(HTML, CSS)
        단어 사이에 하이픈(-)을 작성
        kebab-case

서식문자 - 따옴표 안에서 변수 또는 값을 사용해야 할 때 작성한다.
    반드시 따옴표 안에서 작성한다

    ----------------------------------
    서식문자	설명
    ----------------------------------
    %d	        10진수 정수 표현
    %f	        실수 표현
    %s	        문자열 표현
    ----------------------------------

    변수를 사용하는 이유
    1. 반복되는 값을 쉽게 관리하고자 할 때
    2. 값에 의미 부여를 하기 위해서(자료구조)
    --------------------------------------
    형변환(Casting)
    bin(), oct(), hex(), int(), float(), str(), bool()

### B. 연산자
연산자 - 기능이 있는 특수문자

    1. 산술 연산자

        ----------------------------------
        연산자	예시	설명
        ----------------------------------
        +	    3 + 5	더하기
        -	    3 - 5	빼기
        *	    3 * 5	곱하기
        /	    3 / 5	나누기
        **	    3 ** 5	제곱
        //	    3 // 5	몫
        %	    3 % 5	나머지
        ----------------------------------


    2. 대입(allocation) 연산자

        -------------------------------------------
        연산자	예시	        설명
        -------------------------------------------
        =	    data = 10	    좌항에 우항을 대입
        +=	    data += 10	    data = data + 10
        -=	    data -= 10	    data = data - 10
        *=	    data *= 10	    data = data * 10
        /=	    data /= 10	    data = data / 10
        **=	    data **= 10	    data = data ** 10
        //=	    data //= 10	    data = data // 10
        -------------------------------------------

    3. 비교 연산자

        ※ 조건식 - 참 또는 거짓, 둘 중 하나가 나오는 식
        ※ 조건식은 항상 값으로 본다(True 또는 False)

        ----------------------------------------------------------------
        연산자	예시	                설명
        ----------------------------------------------------------------
        ==	    data == 10	            같으면 True, 같지 않으면 False
        !=, <>	data != 10, data <> 10	같지 않으면 True, 같으면 False
        >	    3 > 5	                보다 크다
        <	    3 < 5	                보다 작다
        >=	    3 >= 5	                이상
        <=	    3 <= 5	                이하
        ----------------------------------------------------------------

    4. 논리 연산자

        ----------------------------------------------------------------
        연산자	예시	            설명
        ----------------------------------------------------------------
        and	    a == b and c == d	조건식 둘 다 True일 경우 True
        or	    a == b or c == d	조건식 둘 중 하나라도 True일 경우 True
        not	    not (a == b)	    True를 False로 False를 True로 변경
        ----------------------------------------------------------------

    5. 멤버 연산자

        -----------------------------------------------------------------------------------------------------
        연산자	예시	                                설명
        -----------------------------------------------------------------------------------------------------
        in	    "a" in "abc", 2 in [1, 2, 3]	        좌항이 우항에 포함되었다면 True 아니면 False
        not in	"a" not in "abc", 2 not in [1, 2, 3]	좌항이 우항에 포함되어 있지 않다면 True 포함되면 False
        -----------------------------------------------------------------------------------------------------

    6. 식별 연산자

        -----------------------------------------------------------------------------------------------------
        연산자	예시	                                    설명
        -----------------------------------------------------------------------------------------------------
        is	    a = 10; b = a; a is b	                    두 객체 모두 같은 주소일 경우 True 아니면 False
        is not	a = [1, 2, 3]; b = [1, 2, 3]; a is not b	두 객체 모두 같은 주소일 경우 True 아니면 False
        -----------------------------------------------------------------------------------------------------

### C. input
입력 상태
    커서가 깜빡이고 있는 상태. 항상 입력 전 출력을 통해 사용자가 정확한 값을 입력할 수 있도록 한다.

입력 함수
    쉘 또는 콘솔에서 입력을 받야야 할 때 사용하며, 입력받은 값은 문자열 값으로 리턴된다.

    input("출력할 메세지")

### D. 제어문
제어문

    컴파일러의 방향을 제어할 수 있는 문법이며, 건너뛰기, 되돌아가기 등이 있다.
    제어문을 통해 프로그램의 구조를 제작할 수 있다.

조건문

    if문

    1.
        if 조건식:
            실행할 문장
        if 조건식:
            실행할 문장
        if 조건식:
            실행할 문장
        ...

    2.
        if 조건식:
            실행할 문장
        elif 조건식:
            실행할 문장
        ...
        else:
            실행할 문장

대입 연산자(복합 대입 연산자, 누적 연산자)

    money = 100000
    # money = money - 70000
    money -= 70000
    print(money)

반복문
    for문: in절 뒤의 요소를 순서대로 변수에 담고 다음 값이 더 이상 없을 경우 종료

    1.
        for 변수명 in range(inclusive_start, exclusive_end, step):
            실행할 문장

    2.
        while 조건식:
            실행할 문장

            
    while문

### E. 데이터 구조(List, Tuple, Dictionary, Set)
    많은 데이터를 쉽고 효과적으로 관리할 수 있는 표준화된 방법을 제공하는 클래스들의 집합.
    
#### 1. dict
    한 쌍으로 저장되어 관리한다.
    len()를 사용하면 한 쌍을 1로 카운트한다.
    키 값은 중복이 될 수 없지만 값은 중복이 가능하다.
    키 값을 주면 그 키의 값을 가지고 온다.

##### 1.1 dict 선언
    dict명 = {키: 값, 키: 값, ...}

##### 1.2 dict 사용
    - 추가, 수정
        dict명[키] = 값
        dict명.update({k:v, k:v, ...}), 있으면 수정, 없으면 추가

    - 삭제
        del dict명[키]

    - 검사
        키 in dict명: 키가 있으면 참
        키 not in dict명: 키가 없으면 참

#### 2. list

    사용 목적
        1. 여러 번 선언하지 않고 한 번만 선언하기 위해서 사용
           변수를 여러 번 선언하면 관리하기 힘들기 때문에 여러 칸 list로 한 번 선언

        2. 규칙성 없는 값에 규칙성을 부여하기 위해서 사용

##### 2.1 리스트 선언
```
- list명 =[]
- list명 = list()
- list명 = [값1, 값2, ...]
- list명 = [값] * 칸수
- list명 = list(range(start, end, step))
```
##### 2.2 리스트 추가
```
- list명.append(data)
- list명.insert(indexNum, data)
```
##### 2.3 리스트 삭제
```
- list명.remove(data)
- del list명[index]
```
##### 2.4 리스트 데이터 수정
```
list명[index] = 수정할 데이터
```

#### 3. Tuple

##### Tuple은 괄호를 이용해 선언할 수 있다.
  - tuple1 = (1, 2, 3, 4)

##### Tuple은 삭제나 추가가 불가능 하다.
    del tuple[1]
    tuple[1] = 'c'

##### Tuple끼리 더하거나 반복하는 것은 가능하다
- tuple2 = (5, 6) <br>
- print(tuple1 + tuple2) <br>
- print(tuple * 3)

#####  tuple로 변수끼리 값을 편하게 바꿀 수 있다
    x = 2 
    y = 3

    (x, y) = (y, x)

    print('x= ',x,'y = ', y)

#### 4. set
##### Set 선언
    
    ppap = {'pen', 'apple', 'pineapple', 'pen'}
    print(ppap)

    'apple' in ppap
    'applepen' in ppap
    
    pineapple = set('pineapple')
    pineapple
    
    A = set('golang')
    B = set('python')

<img src="https://github.com/code-hyun/study_python_crawling/assets/122762287/c6ce7111-7143-4107-87bc-d00435ae83c8" align="left">

### F. 함수

#### 함수 - 이름 뒤에 소괄호, 작성된 코드의 주소값을 담고 있는 저장공간
        f           (x)        2x+1
       함수명      매개변수      리턴값

##### 함수 선언

    def 함수명(매개변수, ...):
        실행할 문장
        return 리턴값

##### 함수를 사용하는 목적

    1. 재사용의 목적
        ※ 절대 특정성을 부여해서는 안된다.

    2. 소스코드 간결화

### G. lambda(람다)

    - 함수를 간단하게 표현한 표현식 → 그 자체로 함수 값 → 변수에 담거나 리턴값으로 사용가능
    - lambda 매개변수 : 리턴
    - 일회용으로 사용할때 사용
    - 리턴값이 없을때 잘 사용하지 않음
    - 함수에 인자로 함수를 전달해야하는 경우 많이사용
    
##### map(함수 , 이터러블한객체) → <class map>
    - 함수부분에 함수를 넣어도 되지만 람다식을 많이 사용
    - 함수를 넣을경우 함수의 이름만 전달 → 함수자체의 주소값 전달 → 람다식자체를 전달 하는것과 같음
    - 이터러블한 객체에서 한개씩 값을 꺼내어 함수에 매개변수로 넣고 그 함수의 리턴값을 맵에 한개씩 담아 완성된 맵 객체를 리턴
    - 기존의 이터러블한 객체에 값의 변경이 필요할 때 사용하는 함수
    - 완성된 맵 객체를 다른 컬렉션으로 변경해 사용
    - 원본 데이터를 훼손하지않음
        
##### filter(함수 , 이터러블 객체) → <class filter>
    - 함수 부분에 함수이름 또는 람다식을 전달
    - 반드시 함수의 리턴값으로 bool타입만 가능
    - 이터러블한 객체에서 한개씩 값을 꺼내어 함수에 매개변수로 넣고 함수의 리턴값이 True인 경우에만 꺼낸 값을 필터객체에 담아 리턴
    - 기존의 이터러블한 객체에서 특정한 조건을 거른 객체가 필요할 때 사용하는 함수
    - 완성된 필터 객체를 다른 컬렉션으로 변경해 사용
    - 원본 데이터를 훼손하지 않음
        
##### reduce(함수,이터러블 객체,초기값) →
    - from functools import reduce 해야함
    - 람다식에 매개변수 반드시 두개 전달
    - 함수의 리턴값이 다음실행 함수의 첫번째 매개변수로 전달
    - 누적 값 얻을때 사용
    - 초기값을 썻다면 초기값이 처음 함수의 첫번째 매개변수로 전달 후 이터러블 객체에서 값을 하나씩 가져와 두번째 매개변수에 전달
       → 다음 함수실행시 첫번째 매개변수는 이전 함수의 리턴값으로 설정
    - 초기값이 없다면 이터러블 객체에서 첫번째 요소와 두번째 요소를 가져와 두개 설정 이후 다음 반복부터는 리턴값이 첫번째 매개변수로 들어감
    - 최종 reduce함수의 리턴값은 누적 연산된 결과값


### H. closure(클로저)
##### 클로저(closure, 폐쇄): 함수 안에 함수, 모듈화
    함수가 정의된 시점의 변수를 기억하고, 이 변수를 나중에 참조 혹은 변경이 가능하도록 해주는 문법이다.
    내부 영역에 선언된 변수는 외부에서 접근이 불가능하기 때문에 데이터 은닉을 할 수 있으며,
    함수가 종료된 이후에도 지역변수에 접근할 수 있기 때문에 데이터 지속성을 가지고 있다.
    또한 다른 함수를 인자로 받거나 리턴할 수 있는 함수형 프로그래밍이 가능해진다.
    하지만 코드 복잡성이 증가하고 지역변수를 메모리에 유지하기 때문에 메모리 사용량이 증가될 수 있다.

    사용 예시)
    def out(arg):
        def in(arg):
            value = operate something
            return value
        return in

    클래스를 지원하지 않는 언어에서 클래스 방식으로 설계하기 위해 클로저를 사용한다.
    Javascript언어가 클로저 방식을 사용하는 대표적인 언어이다.

### I. Class(클래스)
##### 클래스 - 공통 요소를 한 번만 선언하자!

    1. 타입이다.
        클래스 안에 선언된 변수와 메소드를 사용하고 싶다면,
        해당 클래스 타입으로 변수를 선언해야 한다.

    2. 주어이다.
        원숭이가 바나나를 먹는다.
        Monkey.eat("바나나")

##### 클래스 선언
    class 클래스명:
        필드(변수, 메소드)

##### 클래스의 필드 사용
    1. 객체화(instance): 객체(instance variable)를 만드는 작업, 추상적인 개념을 구체화시키는 작업
        객체명 = 생성자()
        객체명.필드명
        ※ .(마침표): 하위 연산자, 멤버변수 접근 연산자, 닷 연산자, 점 연산자
                    주소값 뒤에서만 사용이 가능하며 해당 주소를 참조(접근)하는 명령어이다.
    2. static: 모든 객체가 공유하는 필드이며, 무조건 객체가 아닌 클래스로 직접 접근할 수 있다.
        ※ 만약 static필드를 객체로 접근하면 그 필드는 그 객체에 새롭게 선언된다.
          즉, static 필드는 무조건 클래스 이름으로 접근해야 한다.
          객체로 static 필드를 접근하여 read형태로 사용할 수 있으나,
          write형태로 사용하면 self에 선언된다.

        class A:
            static_variable = 0

        print(A.static_variable)

##### 생성자
    클래스 이름 뒤에 소괄호가 있는 형태, 메소드와 기능이 똑같지만 메소드라고 부르지 않는다.
    생성자는 리턴이라는 기능이 존재하지 않기 때문이다.

##### 기본 생성자
    매개변수가 없는 생성자이며, 클래스 선언 시 자동으로 선언된다.
    사용자가 직접 생성자를 선언하게 되면 자동으로 선언되지 않는다.

##### self
    필드에 접근한 객체가 누구인지 알아야 해당 필드에 접근할 수 있다.
    이 때 접근한 객체가 가지고 있는 필드의 주소값이 self라는 변수에 자동으로 담긴다.

##### 매직 메소드
    클래스 안에 정의할 수 있는 스페셜 메소드이다.


### J. 데코레이터
##### 데코레이터의 사용
    데코레이터는 @ 기호를 사용하여 함수나 메서드 위에 적용됩니다.

    사용 예)
    def my_decorator(func):
    def wrapper():
        print("데코레이터가 실행됨")
        func()
        print("데코레이터 실행이 끝남")
    return wrapper

    @my_decorator
    def say_hello():
        print("안녕하세요!")

    say_hello()

    데코레이터는 파이썬에서 함수형 프로그래밍을 지원하며,
    코드의 재사용성과 가독성을 향상시키는데 큰 도움이 됩니다.

### K. 상속
##### 상속
    기존에 선언된 클래스의 필드를 새롭게 만들 클래스의 필드로 사용하고자 할 때
    여러 클래스 선언 시 필드가 겹치면, 부모 클래스를 선언하고 공통 필드를 묶은 뒤 자식 클래스에게 전달해준다.

##### 상속 문법
    class A{
        A필드
        }
    }

    class B(A){
        A, B필드
        }
    }

    A: 부모 클래스
    B: 자식 클래스   

### L. 모듈
##### 모듈 - 변수와 함수, 클래스 등을 모아 놓은 파이썬 파일
    모듈 사용

    import 모듈명: 사용할 함수의 소속을 직접 코드에 작성하고 모든 함수를 사용하고자 할 때
    import 모듈명 as 사용할 이름: 모듈명이 길거나 복잡할 때 원하는 이름으로 설정해서 사용
    from 모듈명 import 함수명: 모듈명을 직접 코드에 작성하지 않고 함수를 바로 사용하고자 할 때
    from 모듈명 import *: 모듈 안에 있는 모든 함수를 바로 사용하고자 할 때

##### 패키지
    폴더를 생성하여 .py 또는 .ipynb파일을 관리하고자 할 때 해당 폴더를 패키지라고 한다.
    __init__.py 파일을 생성해야 패키지로 인식되지만, 상위 버전(3.3 부터)에서는 __init__.py 파일이 없어도 자동으로 패키지로 인식된다.
    하지만 하위 버전(3.3 미만)에서도 인식되기 위해서는 직접 생성해놓는 것이 좋다.


### M. 예외 처리
    프로그램 실행 중 오류 발생 시 강제 종료되기 떄문에 이를 막기 위하여 예외 처리를 작성한다.
    제어문으로 오류를 막을 수 없는 상황에서는 반드시 예외처리를 작성해야 한다.

##### try, except문

    try:
        오류가 발생할 수 있는 문장

    except 발생오류 as 오류객체:
        오류 발생 시 실행할 문장
    ... <- (except는 여러번 쓸 수 있다는 의미)

    try:
        오류가 발생할 수 있는 문장

    except 발생오류:
        오류 발생 시 실행할 문장
    ...

    try:
        오류가 발생할 수 있는 문장

    except:
        오류 발생 시 실행할 문장
    ...

    finally:
        오류 발생 여부와 상관없이 실행

### N. 파일
    외부에 파일을 생성하거나 내용을 작성할 수 있으며, 기존의 내용도 읽어올 수 있다.

##### 1. 파일 생성하기
    파일을 열고 작성할 때 사용한다.
    'w'를 작성해서 운영체제에게 파일을 여는 목적을 알려줘야 하며, 이 때 'w'를 작성한다.

    open(path, 'w')
    .write() <- 내용쓰기
    
##### 2. 내용 추가하기
    기존의 내용을 덮어 쓰지 않고, 아래의 내용을 추가한다. 이 때에는 추가 모드인 'a'를 작성한다.

    open(path, 'a')

##### 3. 파일 읽기
    기존 내용을 한 줄씩 읽어올 때 'r'를 작성하여 읽기 모드로 파일을 열어준다.

    open(path, 'r')

### O. 제너레이터(Generator)
    한 번에 하나씩 구성요소를 반환해주는 객체
    대용량 데이터 및 많은 반복이 필요한 코드에서 메모리를 적게 사용할 수 있는 고성능 방법
    필요할 때마다 하나씩만 가져오기 때문에 무거운 객체를 다룰 때 사용한다.

##### 1. list comprehension
    [operate for varibale in range(end)]

##### 2. generator expression(comprehension)
    (operate for varibale in range(end))
    
    함수 내에서 return 대신 yield 키워드를 사용하여 next() 실행 시 하나씩 리턴하도록 설계한다.
    
    def test(count=0):
        while True:
            yield count
            count += 1
    
    count = test(10)
    next(count)

<br><br><br><br><br><br><br>

------------------------------------------------------------------------------------------------------------------------------
# Crawling
## 크롤링이란?
    방대한 데이터를 활용할 필요성이 커지고 그러한 정보를 쉽고 활용하기 쉽게 데이터를 수집하는 행위를 크롤링이라고 한다.

### 크롤링의 핵심 코드
    * 라이브러리 임포트
    import requests // 웹페이지 가져오기 라이브러리
    from bs4 import BeautifulSoup // 웹페이지 분석(크롤링) 라이브러리

    * 웹페이지 가져오기
    res = reqeuests.get("웹사이트 주소")

    * 웹페이지 파싱하기
    soup = BeautifulSoup(res.content, 'html.parser')

    * 필요한 데이터 추출하기
    mydata = soup.find('title')

    * 추출한 데이터 활용하기
    print(mydata.get_text())
    
